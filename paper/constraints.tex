%!TEX root = human-constraint-layout.tex
\section{High-Level, User-Defined Constraints}
\smallTree
In this section we describe our constraint language for high-level, user-defined constraints. This languages includes support for specifying sets of nodes over which to run the constraints and three types of constraints over the nodes: \emph{alignment}, \emph{order}, and \emph{position}. Figure \ref{fig:small-tree} shows a small example specification for a tree layout and the resulting six node tree. Every high-level constraint must include a \texttt{"name"} property and specify sets over which to apply the layout constraints. Layout constraints for a high-level constraint are optional.

\subsection{Specifying Sets}
Every high-level constraint must specify a group of sets over which the layout constraints are defined. There are two types of high-level constraints that can be specified: \emph{within set} constraints and \emph{between set} constraints. \emph{Within set} constraints describe constraints that are applied to all of the nodes within a given set whereas \emph{between set} constraints describe constraints that are between larger sets. We describe how to define each type of constraint and show examples of how these constraints are applied.

\subsubsection{Within Set Constraints}
The user specifies \emph{within set} constraints with the \texttt{"set"} property as shown for the \texttt{alignLayer} constraint in Figure \ref{fig:small-tree}. There are two ways to specify sets for \emph{within set} constraints: the user can either partition all the nodes into disjoint sets or the user can specify expressions to create specific sets of nodes.

The simplest set definition is to \texttt{"partition"} nodes into sets based on a property of the node. When generating the sets, the system extracts the property of the node to use as the key for the set. Using \texttt{"partition"}, nodes can only occur in one set specification for the given constraint.

There are two additional properties that users can apply to set partitioning: \texttt{"include"} and \texttt{"exclude"}. \texttt{"include"} allows the user to specify a property of the accepted node to \emph{include} in the set. This property must also be a node, for example the \texttt{"parent"} or \texttt{"firstchild"} of the node. \texttt{"exclude"} represents a list of keys to ignore when creating the sets. This property can be useful for preventing nodes with \texttt{null} properties from being included in the layout. \green{Consider renaming "exclude" to "ignore" so they seem like the match less.}

Alternatively, the user can specify a concrete list of sets to compute. In this representation, the user defines an expression that returns a boolean value of whether or not the node should be included in the set. The user may also specify an optional \texttt{"name"} property that is used by the debugging tools and to \blue{reuse the set across different parts of the specification}. \blue{Using this syntax, it is possible for users to specify sets such that a node can appear in multiple sets.}

\emph{Within set} constraints define constraints that should be applied to all nodes in a set separate from nodes outside the set. In Figure~\ref{fig:small-tree}, the user partitions nodes into sets based on their depth and creates an \emph{alignment} constraint to align the nodes in each set along the x-axis.

\subsubsection{Between Set Constraints}
The user specifies \emph{between set} constraints using the \texttt{"from"} property as shown for the \texttt{orderLayers} constraint in Figure~\ref{fig:small-tree}. The user specifies \emph{between set} constraints as a list of previously named constraints \blue{or explicitly named sets}.

\emph{Between set} constraints define constraints that should be applied between sets but not between nodes in a given set. In Figure~\ref{fig:small-tree}, the user selects all the sets defined by \texttt{alignLayer} and creates an \emph{order} constraint to sort the sets by their depth along the y-axis. In the implementation of \emph{between set} constraints, we define a new constraint between each pair of nodes between sets, which leads to \green{n choose 2} constraints where $n$ is the number of constraints in the graph \green{move this last sentence to the discussion section?}.

\subsection{Specifying Constraints}
Once the user has defined sets of nodes over which to apply the constraints, she may optionally define layout constraints for that specification. Every cosntraint must have a \texttt{"type"} property that defines the type of constraint. We support three types of layout constraints: \emph{alignment} (\texttt{"align"}), \emph{order} (\texttt{"order"}), and \emph{position} (\texttt{"position"}).

\subsubsection{Alignment Constraints}
Alignment constraints are the easiest constraint to specify in our constraint language and define using WebCoLa. Alignment constraints must have two properties, \texttt{"type"} and \texttt{"axis"}, where \texttt{"axis"} can be either \texttt{"x"} or \texttt{"y"}. Figure~\ref{fig:small-tree} shows an example of \emph{alignment} for the high-level constraint \texttt{alignLayer}. Alignment constraints produce one constraint for each set. \green{Consider moving number of discussion section?}

\subsubsection{Order Constraints}
Order constraints have three required properties: \texttt{"type"}, \texttt{"axis"} (either \texttt{"x"} or \texttt{"y"}), and \texttt{"by"}. The property \texttt{"by"} defines the property with which to order the nodes. If the \texttt{"by"} property does not have an obvious ordering (e.g. numeric, alphabetical), the user may optionally define an \texttt{"order"} property that is an ordered list of the expected inputs to the ordering function. The user may also optionally define a \texttt{"reverse"} property to reverse the behavior of the ordering. Figure~\ref{fig:small-tree} shows an example of an \emph{order} constraint for the high-level constraint \texttt{orderLayers}, which forces the layers to be positioned along the y-axis based on their depth.

\subsubsection{Position Constraints}
Position constraints have three required properties: \texttt{"type"}, \texttt{"position"}, and \texttt{"of"}. The property \texttt{"position"} accepts the values \texttt{"right"}, \texttt{"left"}, \texttt{"above"}, or \texttt{"below"}. The \texttt{"of"} property can be defined as a node, for example the \texttt{"parent"} or \texttt{"firstchild"} of the current node, or as a new point. The point definition can include any combination of the properties \texttt{"name"}, \texttt{"x"}, and \texttt{"y"}. If \texttt{"x"} or \texttt{"y"} is not defined, it is initialized to zero by default. Specifying a \texttt{"name"} property allows the new node to be reused in different parts of the specification. \green{consider including an example of this in a figure and providing more detail?} \blue{Figure ? shows the use of \emph{position} constraints for ??.}

\subsection{Built-in Properties}
The constraint specification can use any properties of the nodes in the original graph. However, we also provide a number of built-in properties that can be defined over the nodes. These properties are computed and added to the graph specification prior to computing the final WebCoLa constraints. \blue{These properties are only added to nodes if such a property does not already exist on the nodes.}

\begin{description}
\item[\texttt{\_id}] The index of the node in the original graph specification.
\item[\texttt{depth}] One more than the max depth of the parents of the current node. However, this property is only allowed \blue{if the graph contains only one root node and does not contain cycles}.
\item[\texttt{parent}] The node that has an edge incoming to the current node. This property is only allowed \blue{if the node only has one parent}.
\item[\texttt{firstchild}] The child node of the current node with the smallest \texttt{"\_id"}.
\item[\texttt{incoming}] The list of nodes that have edges incoming to the current node. \green{consider renaming as parents}
\item[\texttt{outgoing}] The list of nodes that have edges outgoing from the current node. \green{consider renaming as children}
\item[\texttt{neighbors}] The list of nodes that have edges connected to the current node. This property is the join of the \texttt{"incoming"} and \texttt{"outgoing"} properties.
\item[\texttt{degree}] The number of \texttt{"neighbors"} for the current node.
\end{description}
