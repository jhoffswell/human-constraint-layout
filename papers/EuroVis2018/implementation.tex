%!TEX root = constraint-layout.tex
\section{Implementation of \projectname~using WebCoLa}
We created an implementation of \projectname\ in which we generate node
specific constraints in WebCoLa~\cite{WebCoLa} based on our high-level
constraints. WebCoLa is an open-source JavaScript library for
creating high-quality, stable constraint layouts, and was therefore a
useful back end to demonstrate the utility of \projectname\ on a number of
examples (see Section \ref{sec:examples}). In this section, we discuss the
constraint generation process for producing WebCoLa constraints and the 
addition of built-in properties of the graph structure.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Generating WebCoLa Constraints}
In WebCoLa, constraints are defined based on the \texttt{\_id} of the
node in the graph specification. For our implementation, we start by
computing the node sets; once we have the sets, we can define the WebCoLa
constraints for the nodes in the set. We leverage two of WebCoLa's
constraint types for our implementation: \emph{alignment} constraints 
and \emph{position} constraints. For other \projectname\ constraints, we
approximate the behavior as described in the following sections.

For each constraint type, we define the number of WebCoLa constraints
generated per \projectname\ constraint. Let $s$ be the number of sets per 
and $n$ be the number of elements per set for each \projectname\ constraint.
Let $g$ be the number of guides defined in the \projectname\ specification.

\subsubsection{Creating Guides in WebCoLa}
\constraint{$O(g)$ new nodes}
In \projectname, the user may define guides to control the graph layout.
To use these guides in WebCoLa constraints, we add a new node to the graph
for each guide and generate constraints relative to this node. These 
temporary nodes are included in WebCoLa's layout but are hidden from the
final visualization of the graph layout.

\subsubsection{Alignment Constraints in WebCoLa}
\constraint{$O(s)$ WebCoLa constraints}
Alignment constraints are one of the constraint types supported by WebCoLa;
once the node sets have been identified, we can generate a single WebCoLa
alignment constraint for each set in each \projectname\ alignment constraint.

\todo{We don't really have alignment working on set elements, only on node elements.}
\todo{Orientation is not working on nodes yet, but shouldn't be too hard to get working}

\subsubsection{Position Constraints in WebCoLa}
\constraint{$O(sn)$ WebCoLa constraints}
Position constraints are also a built-in constraint type in WebCoLa.
Once we have defined the node sets, we generate a WebCoLa position constraint
for each node in the set relative to the global element (i.e., guide node)
that is used in the constraint. We create one WebCoLa constraint for each node
in each set, for each \projectname\ constraint.

\todo{position constraints on set elements}

\subsubsection{Order Constraints in WebCoLa}
\todo{Finalize description of order procedure}
\todo{order constraints on set elements}

\subsubsection{Circle Constraints in WebCoLa}
\constraint{$O(sn)$ new edges}
Circle constraints are not a supported constraint type in WebCoLa. To 
demonstrate the utility of this constraint type we approximated the behavior
in our WebCoLa implementation. To do this, we first add a temporary node
to act as the center of the constraint. We then add a link between each 
node in the set and the temporary center. \todo{Finish...}

\todo{Confirm description of procedure}
\todo{I've looked into two ways of approximating the circle procedure. 
(1) Add edges between each node in the circle and the center, and around
the circle edge. (2) Produce the layout with position constraints and 
then convert to polar coordinates.}

\subsubsection{Unit Constraints in WebCoLa}
\todo{This section}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Built-In Properties of the Graph Structure}
In addition to defining constraints relative to properties arising from
the domain, it may also be important to define constraints on properties
of the graph structure. In our WebCoLa implementation, we support a 
number of built-in properties for the nodes that reflect the graph structure.
These properties are automatically computed and added to the graph 
specification when they are used in one of the \projectname\ constraints. 
These properties are only computed if such a property does not
already exist on the nodes and are subject to a number of expectations
regarding the graph input; for graphs that do not meet these expectations,
users are shown a warning and required to compute the properties
themselves.

\begin{description}
\item[\texttt{\_id}] The node index in the graph specification. This
  property is always computed regardless of whether or not it is used.
\item[\texttt{depth}] One more than the max depth of the node's
  parents. This property is only computed for graphs that contain only one
  root node and do not contain cycles. \todo{Is there a definition for
  graphs with multiple roots (or can we handle disconnected graphs)? Can
  the user specify the root in the specification?}
\item[\texttt{parent}] The parent of the current node. This property is
  only allowed if the node has one parent; otherwise, it is defined as the
  parent with the smallest \texttt{\_id}.
\item[\texttt{firstchild}] The child node of the current node with the smallest \texttt{\_id}.
\item[\texttt{incoming}] The list of nodes that have edges where the
  current node is the target (e.g., all parent nodes).
\item[\texttt{outgoing}] The list of nodes that have edges where the
  current node is the source (e.g., all child nodes).
\item[\texttt{neighbors}] The list of nodes that have edges connected to
  the current node. This property is the join of the \texttt{incoming} and
  \texttt{outgoing} properties.
\item[\texttt{degree}] The number of \texttt{neighbors}.
\end{description}

\todo{confirm all descriptions}

We selected these properties as common structural elements that could be
applicable to layout specifications. For example, the \texttt{depth}
property is useful for producing hierarchical tree layouts and the 
\texttt{incoming}, \texttt{outgoing}, and \texttt{neighbors} properties
reflect structure produced by the graph edges. There are many other
properties that could be useful for graph layouts that are not included 
here; this list could easily be extended in the future to include other
common properties. Furthermore, additional properties can always be
computed by the user and added to the graph prior to running the layout.