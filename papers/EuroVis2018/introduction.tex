%!TEX root = constraint-layout.tex
\section{Introduction}
Graph visualizations can effectively represent properties of the underlying data structure, such as the hierarchy or connectedness of the data within the graph layout. Such visualizations are common across domains including ecological networks \cite{hinke2004visualizing,harper2006dynamic,lavigne1996cod,baskerville2011spatial,yodzis1998local,cohen2003ecological,kearney2016blog,benson2016higher}, biological systems \cite{barsky2008cerebral,shannon2003cytoscape,gehlenborg2010visualization,saraiya2005visualizing,becker2001graph}, and social networks \cite{rothenberg1998using} \orange{[additional citations]}, among many others. The graph layout may utilize domain-specific details in order to emphasize relevant trends in the data. In an ecological network for example, nodes could be split by trophic level (e.g., its positition in the food chain) to highlight the hierarchy of producer/consumer relationships (Figure~\ref{fig:serengeti-layout}). This visualization shows a customized layout: a unique layout that leverages knowledge of the data domain for node placement and understanding of the graph structure.

Many domain-specific layout techniques have been developed to address particular graphing needs for customized layouts \cite{barsky2008cerebral,shannon2003cytoscape,kearney2017d3,kearney2017ecopath}. These techniques leverage common structural details that are significant to the domain, such as known data hierarchies including trophic level (Figure~\ref{fig:serengeti-layout}) or cellular structure (Figure~\ref{fig:tlr4-layout}), as a guiding property of the layout. However, these techniques rarely generalize beyond the domain for which they were designed. There thus exists a mismatch between domains where customized layouts would be useful and the availability of tools to support those domains. When a layout technique does not exist for the domain or task of interest, users are required to either fit their data available techniques or create a new algorithm of their own. Creating a customized layout algorithm can be challenging and often requires both domain and programming expertise; many
\serengetiLayoutColumn
\\domain experts may lack the skills to create custom layouts themselves, thus forcing them to invest large amounts of time into learning the necessary skills or creating a layout by hand. This barrier introduces a gap between the analysis needs of some domains and the availability of techniques to handle those needs.

Constraints are a natural way to identify the desired properties for a customized layout as the designer can think about how domain-specific properties drive the positions of nodes. However, many existing tehcniques for constraint layout require the user to identify inter-node constraints over \emph{pairs} of nodes in the graph. This process can be highly labor intensive, requiring thousands of constraints or careful identification of which nodes should be constrained. Furthermore, these constraints often refer to low-level node properties (such as the node index) and thus introduce a disconnect between the constraint specification and the domain-specific details that drive the specification decision.

To enable the design of customized domain-specific layouts with minimal programming effort, we present \projectname: a domain specific language for specifying high-level constraints for graph layout. Users partition nodes into sets based on node or graph properties and apply layout constraints within or between these sets. This approach allows users to specify layout requirements at a high-level, while deferring the computation of the node-level constraints to the underlying system. These constraint specifications reduce programming effort while still enabling highly customized and generalizable graph layouts. We demonstrate the utility of this technique with an implementation of our constraint language that compiles our high-level constraints into inter-node constraints for WebCoLa~\cite{WebCoLa}, a JavaScript library for constraint based graph layout. To demonstrate the ease and extensibility of our language, we recreate a number of customized layouts with our WebCoLa implementation. We show that users can compactly specify complex graph layouts that resemble those produced by customized layout engines and can reapply layout specifications across different graphs.