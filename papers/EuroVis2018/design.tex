%!TEX root = constraint-layout.tex
\section{Design of \projectname}
\projectname is a domain-specific language for concise specification of 
constrained graph layouts. To provide a reusable specification 
without explicit reference to individual nodes and edges, \projectname
applies constraints to groups of nodes defined by shared attributes. 
The central abstraction in \projectname is a \textbf{set}. At the base level, 
the elements of a set are simply graph nodes; however, \projectname also
supports hierarchical composition, with nested sets as elements.

The core component in \projectname is a \textbf{constraint definition},
which includes both a set definition and constraint application.
\projectname provides a concise set of operators for defining
sets based on node attributes, including structural relations in the graph.
The result of a set definition produces one or more sets, which 
can have either distinct or overlapping elements. Each constraint definition can 
be subject to one or more constraints (e.g., for position, ordering, 
or alignment), which are applied to the nodes within each separate set. 
In other words, constraints for a constraint definition with multiple sets are 
applied to nodes \emph{within} each individual set, not \emph{between} 
the sets in the constraint definition.

A \projectname specification consists of one or more constraint definitions, 
along with an optional set of guides (reference elements that serve as 
positional anchors). The \projectname compiler then takes an input graph 
and specification and produces a set of instance-level constraints for 
an existing constrained graph layout solver. In the following sections, 
we discuss the design of \projectname including the process for 
specifying sets and applying constraints. The data and \projectname 
specification for a small tree layout is shown in Figure~\ref{fig:small-tree-example}.

\smallTreeExample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Specifying Sets in \projectname}
There are several operators for defining sets based on node attributes 
or structural properties, which include (1) \emph{partitioning} nodes 
into disjoint sets, (2) specifying particular sets with \emph{predicates},
and (3) \emph{composing} previously defined sets. Each of these set
definitions produces one or more sets for the constraint definition. For
partitioning or using predicates, the constraint definition may also 
designate a set from which the elements should be drawn; by default, the
elements are simply graph nodes.

\subsubsection{Partitioning nodes into sets}
\constraint{\texttt{partition} by node \emph{depth}}
The partition operator creates a collection of disjoint sets based on
properties of the node (e.g., Figure~\ref{fig:small-tree-example}~Line~\texttt{17}).
Given $n$ nodes to partition, this operator can produce at most $O(n)$ 
sets for a particular constraint definition. The user may further limit 
the number of sets  included by specifying which property values to 
\emph{include} or \emph{exclude} when producing the sets.

For each node, we identify a key based on the node values for the partition
properties and create sets based on the key. The include parameter allows
the user to identify particular node values to look for when partitioning
and includes only those values; the exclude property does the opposite. 
For example in Figure~\ref{fig:serengeti-layout}~Line~\texttt{11}, \texttt{28},
and \texttt{46}, the user partitions the nodes by the \texttt{group} property
and only includes particular groups in each constraint definition to apply
constraints relative to the tropic level of the nodes.

\subsubsection{Specifying sets with predicates}
\constraint{node \emph{depth}\texttt{ == 0}}
For more flexibility in the definition of sets, users
can specify a concrete lists of sets to compute using arbitrary boolean
expressions. For each expression, each node is evaluated by the expression
to determine if it is included in the set. The user may
refer to properties of the node using dot syntax; for example, to extract
the depth the user may write \texttt{node.depth}). Users may also optionally specify a
\texttt{name} for the set, which may be referred to in composition set
definitions. For this specification strategy, it is possible to create
node sets that are not disjoint, and may thus produce unsatisfiable
constraints.

\todo{Extract/Relation/?}

%\subsubsection{Extracting related nodes}
%\constraint{\texttt{extract} node and node \emph{neighbors}}
%For some sets, it may be useful to identify particular
%relationships between nodes, which can be specified as a relation. For each
%node, \todo{finish this section}

\subsubsection{Composing previously defined sets}
\constraint{\texttt{[} \emph{set1}, \emph{set2} \texttt{]}}
Sets may also be formed through the hierarchical
composition of previously defined sets. For example, in Figure
\ref{fig:small-tree-example} the first constraint definition includes a 
set definition that produces three sets using partition~(Line~\texttt{17}),
named ``layer.'' The next constraint definition includes a composition 
that contains only the ``layer'' set~(Line~\texttt{22}). For compositions, the user may
refer to any named entities previously defined in the specification (e.g.,
previous set definitions or named sets produced from \emph{predicates}).
In the current version of \projectname, we only support conjunctions of
sets; in other words, the new set contains only the listed sets.

When a named set is defined, the set element promotes the properties that
are equivalent for all elements in the set to a property of the set
element. For example, in Figure \ref{fig:small-tree-example}, when the user
defines a partition on the nodes based on the \texttt{depth} (Line
\texttt{17}), each set element is given a \texttt{depth} property with
the value for that set. This property may now be referred to in other parts
of the \projectname specification (Line \texttt{23}).

\subsection{Built-In Properties of the Graph Structure}
\todo{Tie this section in better}
In addition to defining constraints relative to properties arising from
the domain, it may also be important to define constraints on properties
of the graph structure. In our WebCoLa implementation, we support a 
number of built-in properties for the nodes that reflect the graph structure.
These properties are automatically computed and added to the graph 
specification when they are used in one of the \projectname\ constraints. 
These properties are only computed if such a property does not
already exist on the nodes and are subject to a number of expectations
regarding the graph input; for graphs that do not meet these expectations,
users are shown a warning and required to compute the properties
themselves.

\begin{description}
\item[\texttt{\_id}] The node index in the graph specification. This
  property is always computed regardless of whether or not it is used.
\item[\texttt{depth}] One more than the max depth of the node's
  parents. This property is only computed for graphs that contain only one
  root node and do not contain cycles. \todo{Is there a definition for
  graphs with multiple roots (or can we handle disconnected graphs)? Can
  the user specify the root in the specification?}
\item[\texttt{parent}] The parent of the current node. This property is
  only allowed if the node has one parent; otherwise, it is defined as the
  parent with the smallest \texttt{\_id}.
\item[\texttt{firstchild}] The child node of the current node with the smallest \texttt{\_id}.
\item[\texttt{incoming}] The list of nodes that have edges where the
  current node is the target (e.g., all parent nodes).
\item[\texttt{outgoing}] The list of nodes that have edges where the
  current node is the source (e.g., all child nodes).
\item[\texttt{neighbors}] The list of nodes that have edges connected to
  the current node. This property is the join of the \texttt{incoming} and
  \texttt{outgoing} properties.
\item[\texttt{degree}] The number of \texttt{neighbors}.
\end{description}

\todo{confirm all descriptions}

We selected these properties as common structural elements that could be
applicable to layout specifications. For example, the \texttt{depth}
property is useful for producing hierarchical tree layouts and the 
\texttt{incoming}, \texttt{outgoing}, and \texttt{neighbors} properties
reflect structure produced by the graph edges. There are many other
properties that could be useful for graph layouts that are not included 
here; this list could easily be extended in the future to include other
common properties. Furthermore, additional properties can always be
computed by the user and added to the graph prior to running the layout.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Applying Constraints in \projectname}
For each constraint definition, the user may define multiple constraints
that are applied to the nodes \emph{within} each individual set. 
By utilizing set composition, the user can build up a hierarchical 
definition of sets and thus effectively produce constraints \emph{between} 
previously defined sets. We discuss the types of constraints currently 
supported in \projectname in Section \ref{sec:constraints}.