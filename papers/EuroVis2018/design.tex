%!TEX root = constraint-layout.tex
\section{Design of \projectname}
\projectname is a domain-specific language for concise specification of 
constrained graph layouts. To provide a reusable specification 
without explicit reference to individual nodes and edges, \projectname
applies constraints to groups of nodes defined by shared attributes. 
The central abstraction in \projectname is a \textbf{set}. At the base level, 
the elements of a set are simply graph nodes; however, \projectname also
supports hierarchical composition, with nested sets as elements.

The core component in \projectname is a \textbf{constraint definition},
which includes both a set definition and constraint application.
\projectname provides a concise set of operators for defining
sets based on node attributes, including structural relations in the graph.
The result of a set definition produces one or more sets, which 
can have either distinct or overlapping elements. Each constraint definition can 
be subject to one or more constraints (e.g., for position, ordering, 
or alignment), which are applied to the nodes within each separate set. 
In other words, constraints for a constraint definition with multiple sets are 
applied to nodes \emph{within} each individual set, not \emph{between} 
the sets in the constraint definition.

A \projectname specification consists of one or more constraint definitions, 
along with an optional set of guides (reference elements that serve as 
positional anchors). The \projectname compiler then takes an input graph 
and specification and produces a set of instance-level constraints for 
an existing constrained graph layout solver. In the following sections, 
we discuss the design of \projectname including the process for 
specifying sets and applying constraints. The data and \projectname 
specification for a small tree layout is shown in Figure~\ref{fig:small-tree-example}.

\smallTreeExample

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Specifying Sets in \projectname}
There are several operators for defining sets based on node attributes 
or structural properties, which include (1) \emph{partitioning} nodes 
into disjoint sets, (2) specifying particular sets with \emph{predicates},
and (3) \emph{composing} previously defined sets. Each of these set
definitions produces one or more sets for the constraint definition. For
partitioning or using predicates, the constraint definition may also 
designate a set from which the elements should be drawn; by default, the
elements are simply graph nodes.

\subsubsection{Partitioning nodes into sets}
\constraint{\texttt{partition} by node \emph{depth}}
The partition operator creates a collection of disjoint sets based on
properties of the node (e.g., Figure~\ref{fig:small-tree-example}~Line~\texttt{17}).
Given $n$ nodes to partition, this operator can produce at most $O(n)$ 
sets for a particular constraint definition. The user may further limit 
the number of sets  included by specifying which property values to 
\emph{include} or \emph{exclude} when producing the sets.

For each node, we identify a key based on the node values for the partition
properties and create sets based on the key. The include parameter allows
the user to identify particular node values to look for when partitioning
and includes only those values; the exclude property does the opposite. 
For example in Figure~\ref{fig:serengeti-layout}~Line~\texttt{11}, \texttt{28},
and \texttt{46}, the user partitions the nodes by the \texttt{group} property
and only includes particular groups in each constraint definition to apply
constraints relative to the tropic level of the nodes.

\subsubsection{Specifying sets with predicates}
\constraint{node \emph{depth}\texttt{ == 0}}
For more flexibility in the definition of sets, users
can specify a concrete lists of sets to compute using arbitrary boolean
expressions. For each expression, each node is evaluated by the expression
to determine if it is included in the set. The user may
refer to properties of the node using dot syntax; for example, to extract
the depth the user may write \texttt{node.depth}). Users may also optionally specify a
\texttt{name} for the set, which may be referred to in composition set
definitions. For this specification strategy, it is possible to create
node sets that are not disjoint, and may thus produce unsatisfiable
constraints.

\todo{Extract/Relation/?}

%\subsubsection{Extracting related nodes}
%\constraint{\texttt{extract} node and node \emph{neighbors}}
%For some sets, it may be useful to identify particular
%relationships between nodes, which can be specified as a relation. For each
%node, \todo{finish this section}

\subsubsection{Composing previously defined sets}
\constraint{\texttt{[} \emph{set1}, \emph{set2} \texttt{]}}
Sets may also be formed through the hierarchical
composition of previously defined sets. For example, in Figure
\ref{fig:small-tree-example} the first constraint definition includes a 
set definition that produces three sets using partition~(Line~\texttt{17}),
named ``layer.'' The next constraint definition includes a composition 
that contains only the ``layer'' set~(Line~\texttt{22}). For compositions, the user may
refer to any named entities previously defined in the specification (e.g.,
previous set definitions or named sets produced from \emph{predicates}).
In the current version of \projectname, we only support conjunctions of
sets; in other words, the new set contains only the listed sets.

When a named set is defined, the set element promotes the properties that
are equivalent for all elements in the set to a property of the set
element. For example, in Figure \ref{fig:small-tree-example}, when the user
defines a partition on the nodes based on the \texttt{depth} (Line
\texttt{17}), each set element is given a \texttt{depth} property with
the value for that set. This property may now be referred to in other parts
of the \projectname specification (Line \texttt{23}).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Applying Constraints in \projectname}

\label{sec:constraints}
Once a collection has been defined, users can apply layout constraints to
each of the sets in the collection. We identify four different types of
constraints that can be applied to set elements: \texttt{alignment},
\texttt{position}, \texttt{order}, \texttt{circle}, and \texttt{unit}. In
the following sections, we describe the behavior and properties of each of
these constraints.

% design section: rationale for why these are the right constructs (sufficiently expressive)
	% why are they user friendly?
	% hypotheses and reason hope/belief/evidence

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Alignment Constraints}
\constraint{\texttt{align} \emph{x} \texttt{axis}} Alignment constraints
specify the alignment of elements along an axis (Figure
\ref{fig:small-tree-example}, Line \texttt{18}). The constraint must
include the \texttt{axis} (e.g., \texttt{x} or \texttt{y}) on which the
elements should be aligned and may optionally include the
\texttt{orientation} for the alignment, one of: \texttt{center},
\texttt{left}, \texttt{right}, \texttt{top}, or \texttt{bottom}. When
applied to nodes, this constraint ensures that all the nodes are aligned
along the \texttt{axis}. When applied to sets, this constraint produces an
alignment based on the centroid or boundary of the set elements.

\emph{Rationale.} Alignment is a common characteristic seen when producing
graphs by hand \orange{citation} or utilizing particular layout strategies
\orange{citation} and is therefore crucial to support in \projectname.

\jheer{Why only x/y axes? Why not polar coordinates, for example? Or along arbitrary line segments defined as guides? I'm not saying you *should* support these, only that it's not clear why you focus where you do. Also I don't totally understand what alignment means here (nor what the default would be if unspecified). Readers may be confused about what you mean by applied to nodes vs. applied to sets, as earlier we talk about sets as the units that constraints are applied to. Also, centroid or boundary, which is used when and why?}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Position Constraints}
\constraint{\texttt{position} \emph{right} \texttt{of}
  \emph{``top\_guide''}} Position constraints specify rules for the layout
of nodes relative to globally identified elements (\orange{figure}). The
constraint must identify a global element (e.g., a guide) to position the
set elements relative to and an orientation for the position (e.g.,
\texttt{left}, \texttt{right}, \texttt{above}, or \texttt{below}). The user
may optionally provide a \texttt{gap} for how far apart the elements should
be from the position element.

\emph{Rationale.} Position constraints allow the user to provide
overarching constraints relative to global elements such as guides. These
can be used to constrain the overall size of the graph or to section off
different areas. \todo{citations}

\jheer{Why only relative guides? Why can't relative position constraints be applied between sets?}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Order Constraints}
\constraint{\texttt{order} \emph{y} \texttt{axis} \texttt{by}
  \emph{``depth''}} Order constraints enforce a sort order on the set
elements (Figure \ref{fig:small-tree-example}, Line \texttt{23}). The
constraint must include the \texttt{axis} (e.g., \texttt{x} or \texttt{y})
on which the elements should be ordered. The constraint must also specify
the node property \texttt{by} which the order is determined. The user can
optionally define an explicit list of values for a custom
\texttt{order}. The user may also optionally include a boolean of whether
or not to \texttt{reverse} the order. Users may finally specify an optional
\texttt{band} property for the constraint that determines a size for each
set region; without the \texttt{band} property, the first and last elements
in the order are free to move on either end, whereas the \texttt{band}
enforces them to fit within the same sized space as the intermediate
elements. \jheer{I don't totally follow what band is.}

\jheer{Similar question as above regarding x/y vs. other possible options.}

\emph{Rationale.} Unlike position constraints, order constraints allow the
user to specify relationships between different sets of nodes to specify
the overall node layout. These relationships are particular useful for
sorting and hierarchical layouts on the different sets of nodes.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Circle Constraints}
\constraint{\texttt{circle} \texttt{around} \emph{``center''}} Circle
constraints allow the user to specify a ring layout for a set of
elements. The constraint must include which element the set elements should
be positioned around or may specify ``center'' for a generic center point
to be used.

\jheer{I'm confused regarding the center. What is a generic center point? Can one specify a x,y point or related guide? What does it mean to put an element in the center? Does this constraint work with sets of sets?}

\emph{Rationale.} Circular structures are a common layout requirement of
existing strategies \orange{citation} and can be crucial for relating
properties of the underlying structure.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Unit Constraints}
\constraint{\texttt{unit}} Unit constraints specify additional layout
properties for elements in the set. The user may optionally specify a
boolean \texttt{enclose} that prevents the set elements from overlapping
with other sets (\orange{figure}). The user may optionally specify an
\texttt{attract} property as either \texttt{center}, \texttt{left},
\texttt{right}, \texttt{top}, or \texttt{bottom} that causes the nodes to
be drawn to the specified area of the set (\orange{figure}). An optional
\texttt{padding} property determines the minimum amount of spacing that
should exist between elements in the unit and finally an optional
\texttt{spacing} property determines whether the spacing is either
\texttt{free} or \texttt{fixed}.

\todo{from Alan: ``attract'' to me connotes a soft constraint. But are
  these constraints actually required? If so, maybe call it ``alignment''
  or something else?} 
\todo{Jane: this section is pretty new, so probably want to discuss in the
meeting this week. The ``unit'' constraints here are supposed to help cover
some of the layout options that are a bit softer than the position and
alignment constraints otherwise discussed in this section. I am not sure
on the naming or anything here really. ``attract'' implies a kind of
organic clustering. Another option for this could be something like ``shape''
with options ``organic'' (the current attract) and ``grid.'' Maybe that would
be better, since I'm not sure it is overly necessary to have this sort of
alignment on the clustering.}

\jheer{We discussed this last week, and believe we decided to break this up into multiple constraints, right?}

\emph{Rationale.} The unit constraint allows the user to enforce more
control on how the nodes within a set behave outside of the general layout
constraints specified earlier. These constraints allow the user to apply
more nuanced behaviors between the nodes.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Unsatisfiable Constraints in \projectname}

For a \projectname\ specification, it is possible to create node sets that
are \emph{not} disjoint and may thus be easily susceptible to the
specification of unsatisfiable constraints. Furthermore, through various
combinations of set specifications and constraint applications, it is
possible for the user to specify unsatisfiable constraints in the
\projectname\ layout. An example of a layout with unsatisfiable constraints
is shown in Figure \ref{fig:contradiction-example}. This layout completes
two partitions of the nodes (once by \texttt{level} and once by
\texttt{rank}); these collections lifted and an order constraint is applied
to enforce a hierarchy between the sets. However, due to the properties of
the nodes, the node with \texttt{rank 10} and \texttt{level 3} faces a
contradiction in the layout. Figure \ref{fig:contradiction-example}c shows
the error on the nodes that have constraints unsatisfied by the layout
(where darker means more error).

\todo{Does it make sense to talk about this here, or should we provide this
  as an example that we talk about later? Or should we talk about it more
  generally without an example and discuss why this is
  allowed?}

\jheer{This section notes that conflicts can arise, but not much else. What facilities if any does the language provide to help with this? How might a user learn that they've authored conflicting constraints? If this is more of a language runtime issue, we might note that there. For example at this point we haven't said anything about how our high-level constraints get translated into low-level constraints.}
