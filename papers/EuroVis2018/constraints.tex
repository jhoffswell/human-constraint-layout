%!TEX root = constraint-layout.tex
\vspace{-5px}
\section{\projectname Constraints and WebCoLa Implementation}
\label{sec:constraints}
Users may specify one or more constraints for each constraint definition.
These constraints apply to the nodes within each set produced by the set definition.
The \projectname compiler converts each \projectname constraint into one or more
constraints in Dwyer~et~al.'s WebCoLa library \cite{WebCoLa}, which computes
the final layout. Figure \ref{fig:constraints} shows the number
of \textbf{Constraint Definitions} and \textbf{\projectname Constraints} written
by the user. We compare the number of \textbf{\projectname Constraints} to
the number of \textbf{WebCoLa Constraints} generated by the \projectname compiler
to show the factor by which the number of constraints increases: \textbf{Ratio
(WebCola/\projectname)}. This ratio is a conservative estimate of the
impact of \projectname, since some \projectname constraints are not
directly converted to WebCoLa.

In \projectname, the user may define guides to control the layout.
In WebCoLa, we add a new node to the graph for each guide and generate 
constraints relative to this node. These temporary nodes are included in 
WebCoLa's layout but are hidden in the final visualization.
WebCoLa constraints are defined based on the \nodeproperty{\_id} of the graph 
node. We leverage two of WebCoLa's constraints for our implementation: 
\emph{alignment} constraints and \emph{position} constraints. For other \projectname constraints, we
approximate their behavior by imputing additional edges or by applying
padding to the nodes. The current implementation of
\projectname provides seven constraint types:
\constraintname{alignment}, \constraintname{position}, \constraintname{order}, \constraintname{circle},
\constraintname{cluster}, \constraintname{hull}, and \constraintname{padding}. These constraints
were selected to produce a range of expressive
graph layouts. In this section, we discuss the design, implementation, 
and utility of each \projectname constraint. We show 
a sample \projectname constraint in each section header.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Alignment Constraints}
\constraint{Ex: \constraintname{align} \setcolavalue{x} \setcolaproperty{axis}}
Alignment constraints ensure that all nodes in the set share one of their
coordinates. For this implementation, the constraint must specify the \setcolaproperty{axis}
as either \setcolavalue{x} or \setcolavalue{y} (\figureline{fig:small-tree-example}{a}{18}).
The user may also optionally identify an \setcolaproperty{orientation} for the alignment.
The orientation is useful for producing alignments when the size of the
elements do not match. By default, the orientation is defined as \setcolavalue{center}
and aligns the center point of each element. When the alignment axis is defined as \setcolavalue{x},
the user may specify the orientation as either \setcolavalue{top} or \setcolavalue{bottom}, which introduces
an offset to align the top or bottom of the nodes. When the alignment axis is 
defined as \setcolavalue{y}, the user may specify the orientation as either \setcolavalue{right} or \setcolavalue{left}.

These constraints are defined as follows.  Suppose that
the user defines the \setcolaproperty{axis}
as \setcolavalue{x} and the \setcolaproperty{orientation} as \setcolavalue{top}.  Then, for all
nodes $n_1$ and $n_2$ in $S$
such that $n_1 \neq n_2$, we produce the constraint
$n_1[y] - height(n_1)/2$ = $n_2[y] - height(n_2)/2$.  Analogous constraints
are produced for the other possible combinations of axis and orientation.
Alignment constraints are one of the constraint types natively supported in
WebCoLa. The WebCoLa alignment constraint takes the \nodeproperty{\_id} of all nodes
that should be aligned and offsets for each node, which can be used to change the orientation.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Position Constraints}
\constraint{Ex: \constraintname{position} \setcolavalue{right} \setcolaproperty{of} \setcolareference{top\_guide}}
Position constraints ensure that all nodes in the set are positioned relative to
a guide or previously named set. The user must specify the relative
placement for the node position as one of \setcolavalue{left}, \setcolavalue{right}, 
\setcolavalue{above}, or \setcolavalue{below} relative to the guide.
The user may optionally provide a \setcolaproperty{gap} that enforces additional spacing
between the nodes and identified guide (\figureline{fig:syphilis-spec}{}{7}).

These constraints are defined as follows. Suppose the user defines the
\setcolaproperty{position} as \setcolavalue{left},
the guide as \setcolareference{g}, and the \setcolaproperty{gap} as \setcolavalue{v}. For all nodes $n$
in $S$, we define a constraint that \mbox{$n[x] + v < g[x]$}.
Position constraints are one of the constraint types natively supported in
WebCoLa. The WebCoLa position constraint is defined by the node 
\nodeproperty{\_id}s, \setcolaproperty{axis}, and desired \setcolaproperty{gap}. For each node
in set $S_1$, we produce one position constraint relative to the specified guide.
When the position constraint is defined relative to a named set $S_2$,
we produce one position constraint for each pair of nodes $(u, v)$ where $u \in S_1$ and $v \in S_2$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Order Constraints}
\constraint{Ex: \constraintname{order} \setcolavalue{y} \setcolaproperty{axis} \setcolaproperty{by} \nodeproperty{depth}}
Order constraints enforce a sort order on the set elements. The user must 
specify the \setcolaproperty{axis} as either \setcolavalue{x} or \setcolavalue{y} and must define
the node property \setcolaproperty{by} which the order is determined 
(\figureline{fig:small-tree-example}{a}{23}). 
The user can optionally define an explicit list of values for a custom
\setcolaproperty{order} (\figureline{fig:tlr4-spec}{}{20}); 
otherwise, the elements are ordered lexicographically \setcolaproperty{by}
the specified property. The user may also indicate whether
or not to \setcolaproperty{reverse} the order of the elements.

These constraints are defined as follows.  Suppose the user defines the \setcolaproperty{axis} as
\setcolavalue{x} and the property to sort \setcolaproperty{by} as \nodeproperty{depth}. For all nodes $n_1$ 
and $n_2$ in $S$  such that $n_1 \neq n_2$ then $n_1[x]$ < $n_2[x]$
if $n_1[depth] < n_2[depth]$. We optimize the implementation of this order
constraint by only producing constraints between adjacent nodes in the sorted 
order; in other words, for a set $S$ with $N$ nodes we produce $O(N)$ 
constraints on the node positions.

When applying constraints to elements that are sets rather than to nodes
directly, we create temporary boundary nodes and compute constraints relative to
these boundaries. Consider a constraint definition that includes $s$ sets. 
In this case, we define $s-1$ boundary guides $b_1, b_2, ..., b_{s-1}$. We then
identify the order of the sets and produce constraints with the internal
nodes for the set. For constraint definition $C$ with $s$ sets, let $S_1$ and
$S_2$ be two adjacent sets such that $S_1 < S_2$ in the sort order. Let $b_1$ be
the boundary between these two sets. We produce constraints such that for all
nodes $n \in S_1$ then $n[x] < b_1[x]$ and for all nodes $m \in S_2$ then $b_1[x] < m[x]$.
Users may optionally specify a \setcolaproperty{band} property (\figureline{fig:syphilis-spec}{}{18})
that determines a size for each set region to introduce fixed spacing between regions.
In this case, we create s + 1 boundary guides and generate additional 
constraints at the start and end of the ordering.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Circle Constraints}
\constraint{Ex: \constraintname{circle} \setcolaproperty{around} \setcolavalue{center}}
Circle constraints allow the user to specify a ring layout for a set of
elements. The user must define the value \setcolaproperty{around} which to compute 
the layout. This value can be either a default \setcolavalue{center} or a previously 
named guide. The user may optionally define a \setcolaproperty{radius} that 
defines the expected radius for the circle (\figureline{fig:syphilis-spec}{}{33}).

Circle constraints are not currently supported in WebCoLa. To
demonstrate the utility of this constraint type we approximate the behavior
in our WebCoLa implementation. To do this, we first add a temporary node
or identify the guide to act as the center of the circle layout.  We
then add a link between each
node in the set and the center. Finally, we link the set nodes in the circle
with additional temporary edges to produce a chain. We compute the expected
length for each edge based on the number of nodes in the circle and the 
\setcolaproperty{radius} defined by the user. This strategy approximates a circular
layout (Figure~\ref{fig:syphilis-layout}b), though future work should
explore the incorporation of alternative strategies for circle layouts~\cite{dwyer2009layout}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Cluster Constraints}
\constraint{Ex: \constraintname{cluster}}
Cluster constraints encourage a tight clustering of the nodes into a dense group by
aiming to reduce the distance between the nodes. This constraint does not
currently introduce addtitional parameters; instead, sets that should be
clustered are simply defined as such (\figureline{fig:serengeti-spec}{c}{12}).
Cluster constraints are not currently supported in WebCoLa. In order to
produce a clustered appearance, we add temporary edges between all nodes
in the set to produce a clique and require the edges to have a length shorter
than the size of the nodes, which pulls the nodes together. These temporary edges
remain a part of the layout but are hidden from the user.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Hull Constraints}
\constraint{Ex: \constraintname{hull}}
Hull constraints create an enclosing boundary (hull) around the set elements and 
prevent any other nodes from residing within that 
boundary~(\figureline{fig:tlr4-spec}{}{28}). 
This constraint produces a visual grouping of nodes that is more strict than the cluster constraint.
These constraints are defined as follows. We produce a minimally enclosing rectangle 
$B$ with properties $B.x1$, $B.x2$, $B.y1$, $B.y2$. For all nodes
$n$ in $S$, we define constraints such that $B.x1 < n[x]$, \mbox{$n[x] < B.x2$},
$B.y1 < n[y]$, $n[y] < B.y2$. For all nodes $m$ not in $S$, we define
constraints such that $m[x] < B[x1]$ $||$ $B[x2] < m[x]$ and $m[y] < B[y1]$ $||$ $B[y2] < m[x]$.
We implement hull constraints in WebCoLa using its built-in support for 
specifying groups, which produce a boundary around 
the nodes defined by their \nodeproperty{\_id}.

% the \mbox above is to force a line break to avoid splitting the equation

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace{-10px}
\subsection{Padding Constraints}
\constraint{Ex: \constraintname{padding} with \setcolaproperty{amount} \setcolavalue{5}}
Padding constraints enforce a minimum spacing around an element, without 
constraining the axis on which the padding is added. The user must define 
the \setcolaproperty{amount} of padding that should be added to the node 
(\figureline{fig:syphilis-spec}{}{27}).
Our current implementation adds padding to the node geometry which 
essentially increases the size of the element
when WebCoLa's non-overlap behavior is applied. In this implementation
padding can only be specified to a given node once and impacts the spacing
relative to all other nodes in the layout.
Additional work is required to develop constraints that
respect the padding only relative to certain set elements.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace{-10px}
\subsection{Application of Multiple Constraints}
\syphilisLayout
\syphilisSpec
These constraints enable expressive layouts for several real-world examples. However, not 
all combinations of constraints produce desirable or satisfiable layouts.
The current implementation of \projectname does not limit the number or
type of constraints that can be applied within a constraint definition.
For example, the user could produce contradictions by defining constraints
that are the reverse of one another (e.g., two order constraints, one with the
ordering reversed). Similarly, applying an alignment constraint to both the \setcolavalue{x}
and \setcolavalue{y} axes would require the nodes to share the same position despite
overall requirements in WebCoLa to avoid node overlap. These concerns are common in
constraint-based systems, and are therefore not limited to \projectname.
The high-level nature of \projectname's constraints can facilitate
interpretation of contradictions since the constraints are defined
relative to domain-specific properties of the nodes rather than between
individual nodes in the graph using only the node \nodeproperty{\_id}.

While some combinations of constraints produce contradictory or overconstrained layouts,
many combinations can produce highly expressive layouts.
For example, the small tree in Figure~\ref{fig:small-tree-example}
effectively combines node alignment with a total ordering on the sets 
to produce a simple specification for a tree layout. Position constraints
generally allow the user to arrange the layout relative to global elements,
whereas order constraints introduce additional sort requirements between nodes
within a particular set. Combining multiple (non-contradictory) position
constraints allows the user to constrain node positions to particular
areas of the visualization, and thus produce overall constraints on the size of the
output or to introduce distinct regions of interest based on node properties.
