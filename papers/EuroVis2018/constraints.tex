%!TEX root = constraint-layout.tex
\section{\projectname Constraints and WebCoLa Implementation}
\label{sec:constraints}

We target  Dwyer et al.'s WebCoLa library \cite{WebCoLa} in order to support
interactive, web-based layouts.
In WebCoLa, constraints are defined based on the \texttt{\_id} of the
graph node. We leverage two of WebCoLa's
constraint types for our implementation: \emph{alignment} constraints 
and \emph{position} constraints. For other \projectname constraints, we
approximate their behavior by imputing additional edges or by applying
padding to the nodes in the layout. The current implementation of
\projectname provides seven constraint types:
\texttt{alignment}, \texttt{position}, \texttt{order}, \texttt{circle},
\texttt{cluster}, \texttt{hull}, and \texttt{padding}. These constraints
were selected to span a range of visualization requirements for expressive
graph layouts. In this section, we discuss the design, implementation, 
and utility of each \projectname constraint. For each subsection, we show 
a sample \projectname constraint in the section header.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Alignment Constraints}
\constraint{Example: \texttt{align} \emph{x} \texttt{axis}}
Alignment constraints ensure that all nodes in the set share one of their
coordinates. For this implementation, the constraint must specify the \texttt{axis}
as either \texttt{x} or \texttt{y}.
The user may also optionally identify an \texttt{orientation} for the alignment.
The orientation is useful for producing alignments when the size of the
elements do not match. By default, the orientation is defined as \texttt{center}
and aligns the center point of each element. When the axis is defined as \texttt{x},
the user may specify either \texttt{top} or \texttt{bottom}, which introduces
an offset to align the top or bottom of the nodes. For \texttt{y} axis
alignment, the user may specify either \texttt{right} or \texttt{left}.

These constraints are defined as follows.  Suppose that
the user defines the \texttt{axis}
as $x$ and the \texttt{orientation} as $top$.  Then, for all
nodes $n_1$ and $n_2$ in $S$
such that $n_1 \neq n_2$, we produce the constraint
$n_1[y] - height(n_1)/2$ = $n_2[y] - height(n_2)/2$.  Analogous constraints
are produced for the other possible combinations of axis and orientation.
Alignment constraints are one of the constraint types natively supported in
WebCoLa. The WebCoLa alignment constraint takes the \texttt{\_id} of all nodes
that should be aligned and offsets for each node that enable changes to the
alignment orientation of the nodes.

% \feedback{Matt}{I'm torn about all the mathematical definitions. Here's what I initially wrote:
% ``\emph{If you can specify something in words as concisely as you can with an
% equation, probably no need for the equation... although if you want it to 
% be more mathy the mathematical definitions probably don't hurt?}''
% But then after reading through 4.2 and 4.3 the definitions seemed kind of 
% nice. But then there kept being more definitions and it got really tedious 
% to read, when really the plane descriptions were much more useful for me 
% to think about it. I think I'd prefer to see a small figure for each type, 
% showing it visually. maybe  annotated to show the most important parts 
% of the math graphically?}

%\jheer{Why only x/y axes? Why not polar coordinates, for example? Or along arbitrary line segments defined as guides? I'm not saying you *should* support these, only that it's not clear why you focus where you do. Also I don't totally understand what alignment means here (nor what the default would be if unspecified). Readers may be confused about what you mean by applied to nodes vs. applied to sets, as earlier we talk about sets as the units that constraints are applied to. Also, centroid or boundary, which is used when and why?}

% When applied to sets, this constraint produces an alignment based on the centroid or boundary of the set elements.
% \todo{We don't really have alignment working on set elements, only on node elements.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Position Constraints}
\constraint{Example: \texttt{position} \emph{right} \texttt{of} \emph{``top\_guide''}}
Position constraints ensure that all nodes in the set are positioned relative to
a guide or previously named set. The user must specify the relative
placement for the position as one of \texttt{left}, \texttt{right}, 
\texttt{above}, or \texttt{below}.
The user may optionally prove a \texttt{gap} that enforces additional spacing
between the nodes and identified guide.

These constraints are defined as follows.  Supppose the user defines the
\texttt{position} as \texttt{left},
the \texttt{guide} as $g$, and the \texttt{gap} as $v$. For all nodes $n$
in $S$, we define a constraint that $n[x] + v < g[x]$.
Position constraints are one of the constraint types natively supported in
WebCoLa, including a \texttt{gap} parameter. For each node
in set $S_1$, we produce one position constraint relative to the specified guide.
When the position constraint is defined relative to a named set $S_2$,
we produce one position constraint for each pair of nodes $(u, v)$ where $u \in S_1$ and $v \in S_2$.

%\jheer{Why only relative guides? Why can't relative position constraints be applied between sets?}
% \todo{This isn't implemented, but probably could be fairly easily. Orange above.}

%\todo{position constraints on set elements}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Order Constraints}
\constraint{Example: \texttt{order} \emph{y} \texttt{axis} \texttt{by} \emph{``depth''}}
Order constraints enforce a sort order on the set elements. The user must 
specify the \texttt{axis} as either \texttt{x} or \texttt{y} and must define
the node property \texttt{by} which the order is determined. 
The user can optionally define an explicit list of values for a custom
\texttt{order}; otherwise, the elements are ordered lexicographically \texttt{by}
the specified property. The user may also indicate whether
or not to \texttt{reverse} the order.

These constraints are defined as follows.  Suppose the user defines the \texttt{axis} as
$x$ and the property to sort \texttt{by} as $depth$. For all nodes $n_1$ 
and $n_2$ in $S$  such that $n_1 \neq n_2$ then $n_1[x]$ < $n_2[x]$
if $n_1[depth] < n_2[depth]$. We optimize the implementation of this order
constraint by only producing constraints between adjacent nodes in the sorted 
order; in other words, for a set $S$ with $N$ nodes we produce $O(N)$ 
constraints on the node position.

When applying constraints to elements that are sets rather than to nodes
directly, we create temporary boundary nodes and compute constraints relative to
these boundaries. Consider a constraint definition that includes $s$ sets. 
In this case, we define $s-1$ boundary guides $b_1, b_2, ..., b_{s-1}$. We then
identify the order of the sets and produce constraints with the internal
nodes for the set. For constraint definition $C$ with $s$ sets, let $S_1$ and
$S_2$ be two adjacent sets such that $S_1 < S_2$ in the sort order. Let $b_1$ be
the boundary between these two sets. We produce constraints such that for all
nodes $n \in S_1$ then $n[x] < b_1[x]$ and for all nodes $m \in S_2$ then $b_1[x] < m[x]$.

Users may also specify an optional
\texttt{band} property for the constraint that determines a size for each
set region. For the \texttt{band} property, users can introduce fixed spacing
to the order of the elements by introducing boundaries between elements. In
this case, we create $s+1$ boundary guides such that we create additional 
constraints at the start and end the ordering.

%\jheer{Similar question as above regarding x/y vs. other possible options.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Circle Constraints}
\constraint{Example: \texttt{circle} \texttt{around} \emph{``center''}}
Circle constraints allow the user to specify a ring layout for a set of
elements. The use must define the value \texttt{around} which to compute 
the layout. This value can be either a default ``center'' or a previously 
named guide. The user may optionally define a \texttt{radius} which 
determines the expected radius for the circle.

\todo{AB: should ``center'' be \texttt{center}?  Not sure why the quotes \ldots}

%\jheer{What does it mean to put an element in the center? Does this constraint work with sets of sets?}

Circle constraints are not a supported constraint type in WebCoLa. To
demonstrate the utility of this constraint type we approximate the behavior
in our WebCoLa implementation. To do this, we first add a temporary node
or identify the guide to act as the center of the circle layout.  We
then add a link between each
node in the set and the center. Finally, we link the set nodes in the circle
with additional temporary edges to produce a chain. We compute the expected
length for each edge based on the number of nodes in the circle and the 
\texttt{radius} defined by the user. This strategy approximates a circular
layout (Figure~\ref{fig:syphilis-layout}), though future work should
explore improved techniques for constraining nodes into a ring layout. 
\todo{Is this something covered by one of Tim's previous projects that we
could cite?}

%\todo{I've looked into two ways of approximating the circle procedure. 
% (1) Add edges between each node in the circle and the center, and around
% the circle edge. (2) Produce the layout with position constraints and 
% then convert to polar coordinates.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Cluster Constraints}
\constraint{Example: \texttt{cluster}}
Cluster constraints encourage a organic clustering of the nodes around
a center point. This constraint should aim to minimize the distance between
the nodes in the set.
Cluster constraints are not currently supported in WebCoLa. In order to
produce a clustered appearance, we add temporary edges between all nodes
in the set to produce a clique and require the edges to have a shorter length,
which encourages the nodes to be drawn together.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Hull Constraints}
\constraint{Example: \texttt{hull}}
Hull constraints create a boundary (hull) around the set elements and 
prevent any other nodes from residing within that boundary. These 
constraints are defined as follows: We produce a minimally enclosing rectangle 
$B$ with properties $B.x1$, $B.x2$ $B.y1$, $B.y2$. For all nodes
$n$ in $S$, we define constraints such that $B.x1 < n[x]$,
\mbox{$n[x] < B.x2$},
$B.y1 < n[y]$, $n[y] < B.y2$. For all nodes $m$ not in $S$, we define
constraints such that $m[x] < B[x1]$ $||$ $B[x2] < m[x]$ and $m[y] < B[y1]$ $||$ $B[y2] < m[x]$.
We implement hull constraints in WebCoLa using its built-in support for 
specifying \texttt{groups}, which produce a boundary around 
the nodes defined by their \texttt{\_id}.

% the \mbox above is to force a line break to avoid splitting the equation

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Padding Constraints}
\constraint{Example: \texttt{padding 5}}
\constraintsFigure
Padding constraints enforce a minimum spacing around an element.
Padding introduces additional space around nodes without constraining the
axis on which the padding is added. Our current implementation adds a
padding to the node geometry which essentially increases the size of the element
when WebCoLa's non-overlap behavior is applied. In this implementation
padding can only be specified to a given node once and impacts the spacing
relative to all other nodes in the layout.
Additional work is required to develop constraints that
respect the padding only relative to certain set elements.

% \jheer{Is the issue here one of applying spacing respected by elements within a set, but which is otherwsie ignored by elements of other sets? If so, this seems like a minor shortcoming (if even a shortcoming at all). I feel like this doesn't really follow our set-based model, but rather serves as a form of global constraint (i.e., applied on the set containing all nodes). Also, if I wanted to give different padding values to different types of nodes (which is then globally respected by the layout) is this possible?}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Creating Guides in WebCoLa}

In \projectname, the user may define guides to control the graph layout.
To use these guides in WebCoLa constraints, we add a new node to the graph
for each guide and generate constraints relative to this node. These 
temporary nodes are included in WebCoLa's layout but are hidden from the
final visualization of the graph layout.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Application of Multiple Constraints}
For this version of \projectname, we selected these constraints to enable
expressive layouts for a variety of real-world examples. These constraints
can be combined in various ways to produce highly flexible graph layouts.
The current implementation of \projectname does not limit or control which
constraints can be applied within a constraint definition, however, not
all constraints can be safely applied at the same time.

For example, the user may easily produce contradictions by defining constraints
that are the reverse of one another (e.g., two order constraints, one with the
ordering reversed). Similarly, an order constraint applied to both the \texttt{x}
and \texttt{y} axes would force the nodes to share the same position despite
overall requirements to avoid node overlap. 

While several strategies produce highly constraint or contradictory layouts, 
there are a variety of constraint combinations that can enable highly 
expressive layouts. The small tree in Figure~\ref{fig:small-tree-example}, for 
example, effectively combines alignment on nodes with a total ordering on sets 
to produce a simple specification for an aligned tree layout. Position constraints
generally allow the user to shift the layout relative to global elements,
whereas order constraints introduce additional requirements between nodes
within a particular set. Combining multiple (non-contradictory) position
constraints allows the user to constrain node positions to particular
areas of the graph, and thus produce overall constraints on the size of the
output graph or distinct regions of interest based on node properties.

\todo{AB: what does ``While several strategies produce highly constraint
  \ldots layouts'' mean?  Should this be overconstrained?  Or something else?}

% \emph{Rationale.} Support for alignment on either the x or y axis allows
% users to produce layouts that exhibit grid like layout properties similar
% to those produced by Kieffer et al.\ \cite{kieffer2016hola}.

% \jheer{This is not a true rationale. Focus on the user needs this meets. Why are grid-like layouts needed or desirable? Why is the fact that Kieffer et al. produce them relevant here? One alternative you could consider is moving your rationale to a dedicated subsection at the end of this section. Some designs are achieved by combining constraints, but listing rationales one-by-one may make it harder to talk about what can be achieved via constraint composition.}
