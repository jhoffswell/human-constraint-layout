%!TEX root = constraint-layout.tex
\section{\projectname Constraints and WebCoLa Implementation}
\label{sec:constraints}
Users may specify one or more constraints for each constraint definition.
These constraints apply to the nodes within each set identified by the set definition.
The \projectname compiler converts each \projectname constraint into one or more
constraints in Dwyer~et~al.'s WebCoLa library \cite{WebCoLa}, which computes
the final layout. Figure \ref{fig:constraints} shows the number
of \textbf{Constraint Definitions} and \textbf{\projectname Constraints} written
by the user. We compare the number of \textbf{\projectname Constraints} to
the number of \textbf{WebCoLa Constraints} generated by the \projectname compiler
to show the increase factor in the number of constraints: \textbf{Ratio 
(WebCola/\projectname)}. This ratio is a conservative estimate of the
overall impact of \projectname since some \projectname constraints are not
directly converted to WebCoLa.

In \projectname, the user may define guides to control the layout.
In WebCoLa, we add a new node to the graph for each guide and generate 
constraints relative to this node. These temporary nodes are included in 
WebCoLa's layout but are hidden from the final visualization.
WebCoLa constraints are defined by the \texttt{\_id} of the graph 
node. We leverage two of WebCoLa's constraints for our implementation: 
\emph{alignment} constraints and \emph{position} constraints. For other \projectname constraints, we
approximate their behavior by imputing additional edges or by applying
padding to the nodes. The current implementation of
\projectname provides seven constraint types:
\texttt{alignment}, \texttt{position}, \texttt{order}, \texttt{circle},
\texttt{cluster}, \texttt{hull}, and \texttt{padding}. These constraints
were selected to produce a range of expressive
graph layouts. In this section, we discuss the design, implementation, 
and utility of each \projectname constraint. We show 
a sample \projectname constraint in each section header.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Alignment Constraints}
\constraint{Ex: \texttt{align} \emph{x} \texttt{axis}}
Alignment constraints ensure that all nodes in the set share one of their
coordinates. For this implementation, the constraint must specify the \texttt{axis}
as either \texttt{x} or \texttt{y} (Figure \ref{fig:small-tree-example}a, Line~\texttt{18}).
The user may also optionally identify an \texttt{orientation} for the alignment.
The orientation is useful for producing alignments when the size of the
elements do not match. By default, the orientation is defined as \texttt{center}
and aligns the center point of each element. When the axis is defined as \texttt{x},
the user may specify either \texttt{top} or \texttt{bottom}, which introduces
an offset to align the top or bottom of the nodes. For \texttt{y} axis
alignment, the user may specify either \texttt{right} or \texttt{left}.

These constraints are defined as follows.  Suppose that
the user defines the \texttt{axis}
as $x$ and the \texttt{orientation} as $top$.  Then, for all
nodes $n_1$ and $n_2$ in $S$
such that $n_1 \neq n_2$, we produce the constraint
$n_1[y] - height(n_1)/2$ = $n_2[y] - height(n_2)/2$.  Analogous constraints
are produced for the other possible combinations of axis and orientation.
Alignment constraints are one of the constraint types natively supported in
WebCoLa. The WebCoLa alignment constraint takes the \texttt{\_id} of all nodes
that should be aligned and offsets for each node, which can be used to change the orientation.

% \feedback{Matt}{I'm torn about all the mathematical definitions. Here's what I initially wrote:
% ``\emph{If you can specify something in words as concisely as you can with an
% equation, probably no need for the equation... although if you want it to 
% be more mathy the mathematical definitions probably don't hurt?}''
% But then after reading through 4.2 and 4.3 the definitions seemed kind of 
% nice. But then there kept being more definitions and it got really tedious 
% to read, when really the plane descriptions were much more useful for me 
% to think about it. I think I'd prefer to see a small figure for each type, 
% showing it visually. maybe  annotated to show the most important parts 
% of the math graphically?}

%\jheer{Why only x/y axes? Why not polar coordinates, for example? Or along arbitrary line segments defined as guides? I'm not saying you *should* support these, only that it's not clear why you focus where you do. Also I don't totally understand what alignment means here (nor what the default would be if unspecified). Readers may be confused about what you mean by applied to nodes vs. applied to sets, as earlier we talk about sets as the units that constraints are applied to. Also, centroid or boundary, which is used when and why?}

% When applied to sets, this constraint produces an alignment based on the centroid or boundary of the set elements.
% \todo{We don't really have alignment working on set elements, only on node elements.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Position Constraints}
\constraint{Ex: \texttt{position} \emph{right} \texttt{of} \emph{``top\_guide''}}
Position constraints ensure that all nodes in the set are positioned relative to
a guide or previously named set. The user must specify the relative
placement for the position as one of \texttt{left}, \texttt{right}, 
\texttt{above}, or \texttt{below}.
The user may optionally provide a \texttt{gap} that enforces additional spacing
between the nodes and identified guide.

These constraints are defined as follows. Suppose the user defines the
\texttt{position} as \texttt{left},
the \texttt{guide} as $g$, and the \texttt{gap} as $v$. For all nodes $n$
in $S$, we define a constraint that $n[x] + v < g[x]$.
Position constraints are one of the constraint types natively supported in
WebCoLa, which includes a \texttt{gap} parameter. For each node
in set $S_1$, we produce one position constraint relative to the specified guide.
When the position constraint is defined relative to a named set $S_2$,
we produce one position constraint for each pair of nodes $(u, v)$ where $u \in S_1$ and $v \in S_2$.

%\jheer{Why only relative guides? Why can't relative position constraints be applied between sets?}
% \todo{This isn't implemented, but probably could be fairly easily. Orange above.}

%\todo{position constraints on set elements}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Order Constraints}
\constraint{Ex: \texttt{order} \emph{y} \texttt{axis} \texttt{by} \emph{depth}}
Order constraints enforce a sort order on the set elements. The user must 
specify the \texttt{axis} as either \texttt{x} or \texttt{y} and must define
the node property \texttt{by} which the order is determined 
(Figure \ref{fig:small-tree-example}a, Line~\texttt{23}). 
The user can optionally define an explicit list of values for a custom
\texttt{order}; otherwise, the elements are ordered lexicographically \texttt{by}
the specified property. The user may also indicate whether
or not to \texttt{reverse} the order of the elements.

These constraints are defined as follows.  Suppose the user defines the \texttt{axis} as
$x$ and the property to sort \texttt{by} as $depth$. For all nodes $n_1$ 
and $n_2$ in $S$  such that $n_1 \neq n_2$ then $n_1[x]$ < $n_2[x]$
if $n_1[depth] < n_2[depth]$. We optimize the implementation of this order
constraint by only producing constraints between adjacent nodes in the sorted 
order; in other words, for a set $S$ with $N$ nodes we produce $O(N)$ 
constraints on the node position.

When applying constraints to elements that are sets rather than to nodes
directly, we create temporary boundary nodes and compute constraints relative to
these boundaries. Consider a constraint definition that includes $s$ sets. 
In this case, we define $s-1$ boundary guides $b_1, b_2, ..., b_{s-1}$. We then
identify the order of the sets and produce constraints with the internal
nodes for the set. For constraint definition $C$ with $s$ sets, let $S_1$ and
$S_2$ be two adjacent sets such that $S_1 < S_2$ in the sort order. Let $b_1$ be
the boundary between these two sets. We produce constraints such that for all
nodes $n \in S_1$ then $n[x] < b_1[x]$ and for all nodes $m \in S_2$ then $b_1[x] < m[x]$.
Users may optionally specify a \texttt{band} property that determines a size for each
set region. For the \texttt{band} property, users can introduce fixed spacing
to the order of the elements by introducing boundaries between elements. 
In this case, we create s + 1 boundary guides and generate additional 
constraints at the start and end of the ordering.

%\jheer{Similar question as above regarding x/y vs. other possible options.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Circle Constraints}
\constraint{Ex: \texttt{circle} \texttt{around} \emph{center}}
Circle constraints allow the user to specify a ring layout for a set of
elements. The user must define the value \texttt{around} which to compute 
the layout. This value can be either a default \texttt{center} or a previously 
named guide. The user may optionally define a \texttt{radius} which 
determines the expected radius for the circle.

%\jheer{What does it mean to put an element in the center? Does this constraint work with sets of sets?}

Circle constraints are not a supported constraint type in WebCoLa. To
demonstrate the utility of this constraint type we approximate the behavior
in our WebCoLa implementation. To do this, we first add a temporary node
or identify the guide to act as the center of the circle layout.  We
then add a link between each
node in the set and the center. Finally, we link the set nodes in the circle
with additional temporary edges to produce a chain. We compute the expected
length for each edge based on the number of nodes in the circle and the 
\texttt{radius} defined by the user. This strategy approximates a circular
layout (Figure~\ref{fig:syphilis-layout}b), though future work should
explore alternative strategies for circle layouts~\cite{dwyer2009layout}.

%\todo{I've looked into two ways of approximating the circle procedure. 
% (1) Add edges between each node in the circle and the center, and around
% the circle edge. (2) Produce the layout with position constraints and 
% then convert to polar coordinates.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Cluster Constraints}
\constraint{Ex: \texttt{cluster}}
Cluster constraints encourage an ``organic'' clustering of the nodes around
a center point. This constraint should aim to minimize the distance between
the nodes. Cluster constraints are not currently supported in WebCoLa. In order to
produce a clustered appearance, we add temporary edges between all nodes
in the set to produce a clique and require the edges to have a length shorter
than the size of the nodes, which pulls the nodes together. These temporary edges
remain a part of the layout but are hidden from the user.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Hull Constraints}
\constraint{Ex: \texttt{hull}}
Hull constraints create a boundary (hull) around the set elements and 
prevent any other nodes from residing within that boundary. These 
constraints are defined as follows: We produce a minimally enclosing rectangle 
$B$ with properties $B.x1$, $B.x2$, $B.y1$, $B.y2$. For all nodes
$n$ in $S$, we define constraints such that $B.x1 < n[x]$,
\mbox{$n[x] < B.x2$},
$B.y1 < n[y]$, $n[y] < B.y2$. For all nodes $m$ not in $S$, we define
constraints such that $m[x] < B[x1]$ $||$ $B[x2] < m[x]$ and $m[y] < B[y1]$ $||$ $B[y2] < m[x]$.
We implement hull constraints in WebCoLa using its built-in support for 
specifying \texttt{groups}, which produce a boundary around 
the nodes defined by their \texttt{\_id}.

% the \mbox above is to force a line break to avoid splitting the equation

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Padding Constraints}
\constraint{Ex: \texttt{padding 5}}
Padding constraints enforce a minimum spacing around an element.
Padding introduces additional space without constraining the
axis on which the padding is added. Our current implementation adds a
padding to the node geometry which essentially increases the size of the element
when WebCoLa's non-overlap behavior is applied. In this implementation
padding can only be specified to a given node once and impacts the spacing
relative to all other nodes in the layout.
Additional work is required to develop constraints that
respect the padding only relative to certain set elements.

% \jheer{Is the issue here one of applying spacing respected by elements within a set, but which is otherwsie ignored by elements of other sets? If so, this seems like a minor shortcoming (if even a shortcoming at all). I feel like this doesn't really follow our set-based model, but rather serves as a form of global constraint (i.e., applied on the set containing all nodes). Also, if I wanted to give different padding values to different types of nodes (which is then globally respected by the layout) is this possible?}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsection{Creating Guides in WebCoLa}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Application of Multiple Constraints}
\syphilisLayout
% \syphilisLayoutColumn
\syphilisSpec
% \syphilisLayoutHybrid
These constraints enable expressive layouts for several real-world examples. However, not 
all combinations of constraints produce desirable or satisfiable layouts.
The current implementation of \projectname does not limit the number or
type of constraints that can be applied within a constraint definition.
For example, the user could produce contradictions by defining constraints
that are the reverse of one another (e.g., two order constraints, one with the
ordering reversed). Similarly, applying an alignment constraint to both the \texttt{x}
and \texttt{y} axes would require the nodes to share the same position despite
overall requirements to avoid node overlap. These concerns are common in
constraint-based systems, and are therefore not limited to \projectname.
The high-level nature of \projectname's constraints can facilitate
interpretation of contradictions since the constraints are defined
relative to domain-specific properties of the nodes rather than between
individual nodes in the graph.

While some combinations of constraints produce contradictory or overconstrained layouts,
many combinations can produce highly expressive layouts.
For example, the small tree in Figure~\ref{fig:small-tree-example}
effectively combines node alignment with a total ordering on the sets 
to produce a simple specification for a tree layout. Position constraints
generally allow the user to arrange the layout relative to global elements,
whereas order constraints introduce additional sort requirements between nodes
within a particular set. Combining multiple (non-contradictory) position
constraints allows the user to constrain node positions to particular
areas of the visualization, and thus produce overall constraints on the size of the
output or to introduce distinct regions of interest based on node properties.

% \emph{Rationale.} Support for alignment on either the x or y axis allows
% users to produce layouts that exhibit grid like layout properties similar
% to those produced by Kieffer et al.\ \cite{kieffer2016hola}.

% \jheer{This is not a true rationale. Focus on the user needs this meets. Why are grid-like layouts needed or desirable? Why is the fact that Kieffer et al. produce them relevant here? One alternative you could consider is moving your rationale to a dedicated subsection at the end of this section. Some designs are achieved by combining constraints, but listing rationales one-by-one may make it harder to talk about what can be achieved via constraint composition.}
