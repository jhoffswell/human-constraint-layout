%!TEX root = constraint-layout.tex
\section{Limitations \& Future Work}
There are a number of useful areas for future work, including optimizations
for the current constraint generation procedure, the development of useful debugging
tools to facilitate the user's understanding of unsatisfiable constraints,
and the evolution of constraint solvers more closely integrated with \projectname.

% wrangler/polestar/lyra strategies for specifying constraints
% dsl leveraged as useful interface for processing logic

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace{-5px}
\subsection{Prototyping and Constraint Generation}
\projectname allows users to define constraints that apply
to groups of nodes rather than applying constraints to individual
nodes one at a time. By deferring this specification complexity to the underlying constraint
solver, the user can more easily prototype the layout and make changes that
have a large overall impact with a small number of written constraints. However, 
the current \projectname compiler is not optimized to reduce the
number of constraints produced. In particular, the procedure for generating
order constraints adds potentially superfluous inter-node 
constraints. For the small tree example (Figure \ref{fig:small-tree-example}c), 
the \projectname compiler produces 11 WebCoLa constraints.
In this example, the \projectname compiler creates two constraints: $b.y < boundary1.y$ (Line~\texttt{44}) 
and $c.y < boundary1.y$ (Line~\texttt{46}), in addition to a
constraint that $b.y == c.y$ (Line~\texttt{32}-\texttt{36}), thus 
making one of the first two constraints superfluous. 
Future work should explore whether these redundant constraints have a 
significant performance impact, and if they do, investigate 
optimizations to reduce the generation of unnecessary constraints.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace{-7px}
\subsection{Debugging and Unsatisfiable Constraints in \projectname}
\projectname specifications may include sets that 
are \emph{not} disjoint and may thus produce unsatisfiable constraints. 
The user may also specify unsatisfiable constraints indirectly through
combinations of set definitions and constraint applications. 
Finally, some specifications may be under-constrained and thus produce
layouts that do not meet the user's needs. Concerns surrounding
debugging and unsatisfiable constraints are not exclusive to \projectname, 
and can also arise in WebCoLa and other constraint-based systems. 

For the constraints described in this paper, it is possible to determine if
conflicts arise at program runtime and highlight such conflicts. One
advantage of the SetCoLa abstraction is that the original user constraints
are defined on the high-level properties of the nodes, which makes it easier to understand why conflicts occur.
In order to debug the constraints, the user may first inspect the sets produced
by \projectname to check for inconsistencies. By identifying
nodes that exist in multiple sets, users can more easily understand the source
of potential conflicts. All WebCoLa constraints generated by the \projectname 
compiler are annotated with the \projectname constraint from which they were generated;
this annotation allows the user to more easily map between the output constraints 
and the original \projectname constraint. While these properties
may help with the debugging process, future work should explore additional
strategies for debugging the graph layout.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace{-7px}
\subsection{Limitations to the Expressiveness}
The current \projectname implementation requires the graph to be fully formed
at input, including all properties (beyond the ones computed in Section 
\ref{sec:built-in-properties}). All the edges and nodes in this graph are
treated with equal weight in terms of the constraints, thus limiting the user's
ability to introduce preferences regarding the importance of the nodes or links. 
Furthermore, there are cases in which the user may want to break links, duplicate parts of 
the graph, or otherwise modify the underlying structure based on properties of interest.
The current \projectname implementation does not support operations to modify the
importance or structure of the input graph, though this would be an interesting
area for future work.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\vspace{-7px}
\subsection{Limitations Arising from the Constraint Solver}

% remember to be generous with WebCoLa when discussing limitations; using a
% system like this makes it easier to uncover bugs or identify
% surprising/unsual behavior in the underlying system.

% what happens to the setCoLa specification when it is NOT on top of
% another system? (e.g. this is applying constraints on top of a number of
% other parameters of the underlying layout solver, so what is it's role
% alone?)

Our implementation with WebCoLa allows us to demonstrate the utility of
\projectname for creating customized domain-specific layouts that can be
reapplied across graphs in the same domain. However, our current
implementation was limited in part by what WebCoLa currently supports. For
example, we were unable to directly express \projectname's circle constraint in
WebCoLa.  However, circle constraints have been identified in the WebCoLa
wiki as an area of future work, and once they are supported in the
underlying constraint solver, it should be straightforward to use
this improved support. Our work contributes new strategies for the
specification of graph layout constraints, but does not aim to create a
highly optimized constraint solver. WebCoLa is a useful
library on which to build and demonstrate our approach, but 
future work might explore how new or existing constraint solvers might
co-evolve alongside this high-level language for constraint specification.

We also encountered some behavioral mismatches between the implementation
of WebCoLa and our expectations for the graph layout. For example, WebCoLa
utilizes a default link length for the layout which attempts to optimize
node positions to produce links as close to the desired link length as
possible. While this technique can be useful for highlighting the underlying 
structure of the graph, it has a significant effect on the layout that is
produced by WebCoLa that may vary from what is specified in \projectname.
This behavior can be beneficial for some layouts.
As noted in Section \ref{sec:syphilis-example}, in the syphilis social network
(Figure~\ref{fig:syphilis-layout}b), the circle is drawn slightly off
center between the groups since more links exist between the
women and the African-American men than between the women and
the white men, which emphasizes the strength of these connections.
% Revisting the syphilis social network
% (Figure~\ref{fig:syphilis-layout}b), many of the nodes in the upper group
% are drawn to the lower position allowed by the boundary guide in an attempt
% to shorten the link length, thus producing an alignment that satisfies the
% \projectname constraints but not all of whose properties are explicitly
% specified in the layout. 
The underlying constraint solver can thus
significantly impact the resulting layout by implicitly encoding
additional preferences. In future work, it may be useful to support
additional parameters expressing global preferences for the graph layout,
which would then be passed on to the underlying solver. Another direction
would be to accommodate multiple solvers, which might encode different
preferences of these kinds, and to select among them, either automatically
or as specified by the user.

Another interesting behavior of WebCoLa is that a global non-overlap constraint
may be applied to the nodes at the start of the overall layout. This constraint
prevents nodes from overlapping even at intermediate stages of the layout and
may thus cause the layout to become stuck in a local optimum that still
includes unsatisfied constraints. Furthermore, our use of
dummy guide nodes with a fixed position may further complicate issues
with local maxima. Future work might explore additional procedures for
iteratively adding constraints to the graph layout, building up the final
result incrementally. This technique would help to reduce some of the burdens
on the layout to resolve all constraints at once and allow the user to
incrementally improve the layout through the addition of new constraints
that restart the underlying solver.
