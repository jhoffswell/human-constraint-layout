%!TEX root = constraint-layout.tex
\section{Limitations \& Future Work}
There are a number of useful areas for future work, including optimizations
for the current constraint generation procedure, the development of useful debugging
tools to facilitate the user's understanding of unsatisfiable constraints,
and the evolution of constraint solvers more closely integrated with \projectname.

% wrangler/polestar/lyra strategies for specifying constraints
% dsl leveraged as useful interface for processing logic

\subsection{Prototyping and Constraint Generation}
\projectname allows users to easily produce layout constraints that apply
to groups of nodes in a graph rather than applying constraints to individual
nodes one at a time. By deferring this complexity to the underlying constraint
solver, the user can more easily prototype the layout and make changes that
have a large overall impact with a small number of constraints.
As shown in Figure~\ref{fig:constraints},
the number of \projectname constraints is a small fraction of the WebCoLa constraints.

The current WebCoLa implementation is not completely optimized to reduce the
number of constraints. In particular, the procedure for generating
order constraints adds a number of potentially superfluous inter-node 
constraints. For the small tree example, the current \projectname implementation 
produces 11 WebCoLa constraints (Figure \ref{fig:small-tree-example}c). For example,
the \projectname compiler creates two constraints: $b.y < boundary1.y$ (Line~\texttt{44}) 
and $c.y < boundary1.y$ (Line~\texttt{46}), even though we also specify
a constraint that says $b.y == c.y$ (Line~\texttt{32}-\texttt{36}). 
Future work could explore whether these redundant constraints have a 
significant performance impact, and if they do, investigate additional 
optimizations to reduce the generation of unnecessary constraints.

\subsection{Debugging and Unsatisfiable Constraints in \projectname}
For a \projectname specification, it is possible to create node sets that
are \emph{not} disjoint and may thus produce unsatisfiable constraints. Furthermore, 
the user may specify unsatisfiable constraints indirectly through
combinations of set definitions and constraint applications. These concerns
are not exclusive to \projectname, as they can also arise
in WebCoLa and other constraint-based layout tools.

For the constraints described in this paper, it is possible to determine if
conflicts arise at program runtime and show such conflicts to the user. One
advantage of the SetCoLa abstraction is that the original user constraints
are defined on the high-level properties of the nodes and therefore it may
be easier to understand why the conflicts are occurring. For example, we may
note that some nodes occur in multiple sets with conflicting constraints
or that multiple constraints on a particular set are generally in conflict.

\subsection{Limitations Arising from the Constraint Solver}

% remember to be generous with WebCoLa when discussing limitations; using a
% system like this makes it easier to uncover bugs or identify
% surprising/unsual behavior in the underlying system.

% what happens to the setCoLa specification when it is NOT on top of
% another system? (e.g. this is applying constraints on top of a number of
% other parameters of the underlying layout solver, so what is it's role
% alone?)

Our implementation with WebCoLa allows us to demonstrate the utility of
\projectname for creating customized domain-specific layouts that can be
reapplied to multiple graphs in the same domain. However, our current
implementation was limited in part by what WebCoLa currently supports. For
example, we were unable to directly express \projectname's circle constraints in
WebCoLa.  However, circle constraints have been identified in the WebCoLa
wiki as an area of future work, and once they are supported in the
underlying constraint solver, it should be straightforward to make use of
this improved support in \projectname.
Our work contributes new strategies for the
specification of graph layout constraints, but does not aim to create a
highly optimized constraint solver for the language. WebCoLa is a useful
library on which to build and demonstrate our approach, but 
future work might explore how new or existing constraint solvers might
co-evolve alongside this high-level language for constraint specification.

We also encountered some behavioral mismatches between the implementation
of WebCoLa and our expectations for the graph layout. For example, WebCoLa
utilizes a default link length for the layout which attempts to optimize
node positions to produce links as close to the desired link length as
possible. While this technique can be useful for highlighting the underlying 
structure of the graph, it has a significant effect on the layout that is
produced by WebCoLa that may vary from what is specified in \projectname.
This behavior can be beneficial for some layouts, such as the syphilis social network.
As noted in Section \ref{sec:examples}, in the syphilis social network
(Figure~\ref{fig:syphilis-layout}b), the circle is drawn slightly off
center between the groups since more links exist between the
women and the African-American men than between the women and
the white men, which emphasizes the strength of these
connections.

Revisting the syphilis social network
(Figure~\ref{fig:syphilis-layout}b), many of the nodes in the upper group
are drawn to the lower position allowed by the boundary guide in an attempt
to shorten the link length, thus producing an alignment that satisfies the
\projectname constraints but not all of whose properties are explicitly
specified in the layout. The underlying constraint solver can thus
significantly impact the resulting layout, since it may implicitly encode
additional preferences.  In future work, it may be useful to support
additional parameters expressing global preferences for the graph layout,
which would then be passed on to the underlying solver.  Another direction
would be to accommodate multiple solvers, which might encode different
preferences of these kinds, and to select among them, either automatically
or as specified by the user.

Another interesting behavior of WebCoLa is that a global non-overlap constraint
may be applied to the nodes at the start of the overall layout. This constraint
prevents nodes from overlapping even at intermediate stages of the layout and
may thus cause the layout to become stuck in a local optimum that still
includes unsatisfied constraints. Furthermore, our use of
dummy guide nodes with a fixed position may further complicate issues
with local maxima. Future work might explore additional procedures for
iteratively adding constraints to the graph layout, building up the final
result incrementally. This technique would help to reduce some of the burdens
on the layout to resolve all constraints at once and allow the user to
incrementally improve the layout through the addition of new constraints
that restart the underlying solver.
